const fs = require('fs');
const { promisify } = require('util');
const jsStringEscape = require('js-string-escape');
const LogUtility = require('./logUtility');
const PathUtility = require('./pathUtility');

const readFileAsync = promisify(fs.readFile);
const readdirAsync = promisify(fs.readdir);
const writeFileAsync = promisify(fs.writeFile);

const tabSize = 4; // move to markup utility
const NEW_LINE = '\r\n';
const TAB = new Array(parseInt(tabSize, 10) + 1).join(' ');
const autoGenStr = `// This file is AUTOGENERATED, do not edit it manually!!!${NEW_LINE}`;

const writeOptions = { flag: 'w', mode: 666, encoding: 'utf8' }; // перетянуть, повторения выкосить
const tsLintDisable = `// tslint:disable${NEW_LINE}`;

// const getChunkByFileName = fileName => fileName.split('.')[0];
// const getChunksNames = fileNames => fileNames.map(getChunkByFileName) // ^^
//     .filter((v, i, a) => a.indexOf(v) === i);

class DistGenerator {
    constructor(jsNamespace, languages, defaultLang, resxPrefix, srcFolder, currentLangNS, tsGlobInterface) {
        this.pathUtility = new PathUtility();
        this.jsNamespace = jsNamespace;
        this.languages = languages;
        this.defaultLang = defaultLang;
        this.resxPrefix = resxPrefix;
        this.srcFolder = srcFolder;
        this.currentLangNS = currentLangNS;
        this.tsGlobInterface = tsGlobInterface;
    }

    static genResxStrs(json) {
        const keys = Object.keys(json).sort();
        return keys.map(k => `${TAB}${k}: '${jsStringEscape(json[k])}',`);
    }

    static genResxObj(content, name) {
        return `export const ${name} = {${content ? NEW_LINE + content + NEW_LINE : ''}};`;
    }

    genNameSpaceAssign() {
        return `${this.jsNamespace} = ${this.jsNamespace} || {};${NEW_LINE}`;
    }

    genLangsMapObj(chunk) {
        const mapObjBody = this.languages.map(l => `${TAB}${l}: ${chunk}${l},`).join(NEW_LINE);
        const langsMapObj = `const langMap: {[k: string]: any} = {${NEW_LINE}${mapObjBody}${NEW_LINE}};`;
        return langsMapObj;
    }

    genAssignToNameSpace(chunkName, wrapperChunkName) {
        return `${this.jsNamespace}.${chunkName} = ${wrapperChunkName || chunkName};`;
    }

    static genResxDistBody(name, langData) {
        const keyValPairsToGenerate = Object.keys(langData)
            .filter(k => langData[k] !== null)
            .reduce((acc, k) => {
                acc[k] = langData[k];
                return acc;
            }, {});

        const strings = DistGenerator.genResxStrs(keyValPairsToGenerate);

        return [
            autoGenStr,
            NEW_LINE,
            DistGenerator.genResxObj(strings.join(`${NEW_LINE}`), name),
        ].join('');
    }

    static processJsonToJs(body, filePath) {
        return writeFileAsync(filePath, body + NEW_LINE, writeOptions)
            .then(() => console.log(`${filePath} file is regenerated`))
            .catch(LogUtility.logErr);
    }

    regenerateLangDist() {
        return this;
    }

    static getSortedSrcKeys(fileData) {
        return Object.keys(JSON.parse(fileData)).sort();
    }

    static genResxGetterStrs(keys, defaultLang, currentLangNS) {
        const strings = keys.map(k => (
            `${TAB}get ${k}() {${NEW_LINE}${TAB}${TAB}return langMap[${currentLangNS}].${k} || langMap.${defaultLang}.${k};${NEW_LINE}${TAB}},`
        ));
        const ResxGetterStrs = strings.join(`${NEW_LINE}`);
        return ResxGetterStrs;
    }

    genResxWrapperBody(fileData, chunkName) {
        const wrapperChunkName = chunkName + this.resxPrefix;
        const keys = DistGenerator.getSortedSrcKeys(fileData);
        const imports = DistGenerator.generateNamedImports(chunkName, this.languages, this.resxPrefix);
        const langsMapObj = this.genLangsMapObj(chunkName);
        const content = DistGenerator.genResxGetterStrs(keys, this.defaultLang, this.currentLangNS);
        const resxObj = DistGenerator.genResxObj(content, wrapperChunkName);
        const nameSpaceAssign = this.genAssignToNameSpace(chunkName, wrapperChunkName);

        const body = [
            autoGenStr,
            NEW_LINE,
            imports,
            NEW_LINE,
            NEW_LINE,
            langsMapObj,
            NEW_LINE,
            NEW_LINE,
            resxObj,
            NEW_LINE,
            NEW_LINE,
            nameSpaceAssign,
        ].join('');

        return body;
    }

    static generateNamedImports(chunkName, languages, resxPrefix) {
        return languages.sort().map(l => `import { ${chunkName} as ${chunkName}${l} } from './${chunkName}${resxPrefix}.${l}';`).join(NEW_LINE);
    }

    static genIStrs(json) {
        const keys = Object.keys(json).sort();
        return keys.map(k => `${TAB}${k}: string;`);
    }

    genIGlob(chunkName) {
        return `declare interface ${this.tsGlobInterface} {${NEW_LINE}${TAB}${chunkName}: ${chunkName}${this.resxPrefix};${NEW_LINE}}`;
    }

    genIObj(content, name) {
        return `interface ${name}${this.resxPrefix} {${NEW_LINE}${content}${NEW_LINE}}`;
    }

    genTypesBody(name, data) {
        const content = JSON.parse(data);
        const strings = DistGenerator.genIStrs(content);
        return [
            autoGenStr,
            tsLintDisable,
            NEW_LINE,
            this.genIObj(strings.join(`${NEW_LINE}`), name),
            NEW_LINE,
            NEW_LINE,
            this.genIGlob(name),
        ].join('');
    }

    generateChunkWrapper(srcLangFileData, chunkName) {
        const resxWrapperBody = this.genResxWrapperBody(srcLangFileData, chunkName);
        const filePath = this.pathUtility.getDistWrapperPath(chunkName);
        return DistGenerator.processJsonToJs(resxWrapperBody, filePath);
    }

    generateTypes(srcLangFileData, chunkName) {
        const typePath = this.pathUtility.getDefTypesPath(chunkName);
        const typeBody = this.genTypesBody(chunkName, srcLangFileData);
        return writeFileAsync(typePath, typeBody + NEW_LINE, writeOptions);
    }

    regenerateChunkDist(chunkName) {
        const chunkDefaultSrc = this.pathUtility.getDefSrcFilePath(chunkName);
        readFileAsync(chunkDefaultSrc, { encoding: 'utf8' })
            .then(srcLangFileData => {
                const wrapperRegenOp = this.generateChunkWrapper(srcLangFileData, chunkName);
                const typesRegenOp = this.generateTypes(srcLangFileData, chunkName);
                return Promise.all([wrapperRegenOp, typesRegenOp]);
            })
            .then(() => this.regenerateDist());
    }

    regenerateDist(interactive) {
        LogUtility.logSection('regenerating dist files');
        readdirAsync(this.srcFolder)
            .then(srcDirData => {
                if (srcDirData.length) {
                    const genDistOps = srcDirData.map(srcFileName => {
                        const filenameData = srcFileName.split('.');
                        const [chunkName, lang] = filenameData;
                        const srcFilePath = `${this.srcFolder}${srcFileName}`;
                        
                        return readFileAsync(srcFilePath, { encoding: 'utf8' })
                            .then(srcLangFileData => {
                                const langJSData = JSON.parse(srcLangFileData);
                                const resxBody = DistGenerator.genResxDistBody(chunkName, langJSData);
                                
                                const filePath = this.pathUtility.getDistFilePath(chunkName, lang);
                                return DistGenerator.processJsonToJs(resxBody, filePath);
                            })

                            .catch(LogUtility.logErr);
                    });
                            
                    return Promise.all(genDistOps)
                        .then(() => {
                            if (interactive) {
                                // askForRecursiveActions();
                            }
                            else {
                                LogUtility.logSuccess();
                            }
                        })
                        .catch(LogUtility.logErr);
                    // });
                }
                return LogUtility.logErr('NOTHING TO REGENERATE');
            })
            .catch(LogUtility.logErr);
    }
}

module.exports = DistGenerator;
