const fs = require('fs');
const { promisify } = require('util');
const jsStringEscape = require('js-string-escape');
const LogUtility = require('./logUtility');
const PathUtility = require('./pathUtility');

const readFileAsync = promisify(fs.readFile);
const readdirAsync = promisify(fs.readdir);
const writeFileAsync = promisify(fs.writeFile);

const tabSize = 4; // move to markup utility
const NEW_LINE = '\r\n';
const TAB = new Array(parseInt(tabSize, 10) + 1).join(' ');
const autoGenStr = `// This file is AUTOGENERATED, do not edit it manually!!!${NEW_LINE}`;

const writeOptions = { flag: 'w', mode: 666, encoding: 'utf8' }; // перетянуть, повторения выкосить

// const getChunkByFileName = fileName => fileName.split('.')[0];
// const getChunksNames = fileNames => fileNames.map(getChunkByFileName) // ^^
//     .filter((v, i, a) => a.indexOf(v) === i);

class DistGenerator {
    constructor(jsNamespace, languages, defaultLang, resxPrefix, srcFolder) {
        this.pathUtility = new PathUtility();
        this.jsNamespace = jsNamespace;
        this.languages = languages;
        this.defaultLang = defaultLang;
        this.resxPrefix = resxPrefix;
        this.srcFolder = srcFolder;
    }

    static genResxStrs(json) {
        const keys = Object.keys(json).sort();
        return keys.map(k => `${TAB}${k}: '${jsStringEscape(json[k])}',`);
    }

    static genResxObj(content, name) {
        return `export const ${name} = {${content ? NEW_LINE + content + NEW_LINE : ''}};`;
    }

    genNameSpaceAssign() {
        return `${this.jsNamespace} = ${this.jsNamespace} || {};${NEW_LINE}`;
    }

    genAssignToNameSpace(name) {
        return `${this.jsNamespace}.${name} = ${name};`;
    }

    static genResxDistBody(name, langData) {
        const keyValPairsToGenerate = Object.keys(langData)
            .filter(k => langData[k] !== null)
            .reduce((acc, k) => {
                acc[k] = langData[k];
                return acc;
            }, {});

        const strings = DistGenerator.genResxStrs(keyValPairsToGenerate);

        return [
            autoGenStr,
            NEW_LINE,
            // this.genNameSpaceAssign(),
            // NEW_LINE,
            DistGenerator.genResxObj(strings.join(`${NEW_LINE}`), name),
            // NEW_LINE,
            // NEW_LINE,
            // this.genAssignToNameSpace(name),
        ].join('');
    }

    processJsonToJs(chunkName, body, lang) {
        const filePath = this.pathUtility.getDistFilePath(chunkName, lang);
        return writeFileAsync(filePath, body + NEW_LINE, writeOptions)
            .then(() => console.log(`${filePath} file is regenerated`))
            .catch(LogUtility.logErr);
    }

    regenerateLangDist() {
        return this;
    }

    static getSortedSrcKeys(fileData) {
        return Object.keys(JSON.parse(fileData)).sort();
    }

    static genResxGetterStrs(keys) {
        // get label() {return locales[ep.currentCulture].label ||  locales.en.label},
        return keys.map(k => `${TAB}get ${k}() { return locales[ep.currentCulture].label || locales.en.label; },`);
    }

    genResxWrapper(fileData, chunkName) {
        const keys = DistGenerator.getSortedSrcKeys(fileData);
        const content = DistGenerator.genResxGetterStrs(keys);
        const imports = DistGenerator.generateNamedImports(chunkName, this.languages);
        const body = DistGenerator.genResxObj(content, chunkName + this.resxPrefix);
        
        const a = 1;
    }

    static generateNamedImports(chunkName, languages) {
        return languages.map(l => {
            return `import { ${chunkName} as ${chunkName}${l} } from './${chunkName}.${l}'`;
        }).join(NEW_LINE);
    }

    regenerateChunkDist(chunkName) {
        const chunkDefaultSrc = this.pathUtility.getDefSrcFilePath(chunkName);
        readFileAsync(chunkDefaultSrc, { encoding: 'utf8' })
            .then(srcLangFileData => {
                const imports = DistGenerator.generateNamedImports(chunkName, this.languages);
                const resxBody = this.genResxWrapper(srcLangFileData, chunkName);
                
                //return this.processJsonToJs(chunkName, resxBody, lang);
            })
            .then(() => {
                return this.regenerateDist();
            }); 
        
    }

    regenerateDist(interactive) {
        LogUtility.logSection('regenerating dist files');
        readdirAsync(this.srcFolder)
            .then(srcDirData => {
                if (srcDirData.length) {
                    const genDistOps = srcDirData.map(srcFileName => {
                        const filenameData = srcFileName.split('.');
                        const [chunkName, lang] = filenameData;
                        const srcFilePath = `${this.srcFolder}${srcFileName}`;
                        
                        return readFileAsync(srcFilePath, { encoding: 'utf8' })
                            .then(srcLangFileData => {
                                const langJSData = JSON.parse(srcLangFileData);
                                const resxBody = DistGenerator.genResxDistBody(chunkName, langJSData);
                                return this.processJsonToJs(chunkName, resxBody, lang);
                            })

                            .catch(LogUtility.logErr);
                    });
                    // return Promise.all(genDistOps)
                    //     .then(() => {
                    //         const genTypesOps = getChunksNames(srcDirData).map(chunkName => {
                    //             const defaultSrcPath = this.pathUtility.getDefSrcFilePath(chunkName);
                                
                    //             let typeBody;
                    //             let typePath;

                    //             return readFileAsync(defaultSrcPath, { encoding: 'utf8' })
                    //                 .then(defaultSrcData => {
                    //                     typePath = getDefTypesPath(chunkName);
                    //                     typeBody = genTypesBody(chunkName, defaultSrcData);
                    //                     writeFileAsync(typePath, typeBody + NEW_LINE, writeOptions);
                    //                 })
                    //                 .then(() => {
                    //                     console.log(`${typePath} - file is regenerated`);
                    //                 })
                    //                 .catch(LogUtility.logErr);
                    //         });
                            
                    return Promise.all(genDistOps)
                        .then(() => {
                            if (interactive) {
                                // askForRecursiveActions();
                            }
                            else {
                                LogUtility.logSuccess();
                            }
                        })
                        .catch(LogUtility.logErr);
                    // });
                }
                return LogUtility.logErr('NOTHING TO REGENERATE');
            })
            .catch(LogUtility.logErr);
    }
}

module.exports = DistGenerator;
