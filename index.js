const fs = require('fs');
const { promisify } = require('util');
const inquirer = require('inquirer');
const program = require('commander');
const colors = require('colors');

const readFileAsync = promisify(fs.readFile);
const readdirAsync = promisify(fs.readdir);
const writeFileAsync = promisify(fs.writeFile);

const initModule = ({
    tabSize, srcFolder, distFolder, resxPrefix, jsNamespace, tsGlobInterface, languages,
}) => {
    const NEW_LINE = '\r\n';
    const TAB = new Array(parseInt(tabSize, 10) + 1).join(' ');
    const defaultLang = languages[0];
    const writeOptions = { flag: 'w', mode: 666, encoding: 'utf8' };
    const yesNo = {
        yes: 'Yes',
        no: 'No',
    };

    const yesNoList = [
        { name: yesNo.yes },
        { name: yesNo.no },
    ];

    const autoGenStr = `// This file is AUTOGENERATED, do not edit it manually!!!${NEW_LINE}`;
    const tsLintDisable = `// tslint:disable${NEW_LINE}`;

    const getSrcFilePath = (chunkName, lang) => `${srcFolder}${chunkName}.${lang}.json`;
    const getDefSrcFilePath = chunkName => getSrcFilePath(chunkName, defaultLang);
    const getDistFilePath = (chunkName, lang) => `${distFolder}${chunkName}${resxPrefix}.${lang}.js`;
    const getDefTypesPath = chunkName => `${distFolder}${chunkName}${resxPrefix}.${defaultLang}.d.ts`;

    const logErr = err => console.log(colors.red(`ERROR: ${err}`));

    const genLogSection = sectionText => {
        console.log('-----------------------');
        console.log(`${sectionText}`);
        console.log('-----------------------');
    };


    const genNamespaceAssign = () => `${jsNamespace} = ${jsNamespace} || {};${NEW_LINE}`;
    const genResxObj = (content, name) => `${jsNamespace}.${name} = {${NEW_LINE}${content}${NEW_LINE}};`;
    const genResxStrs = json => {
        const keys = Object.keys(json).sort((a, b) => a > b);
        return keys.map(k => `${TAB}${k}: '${json[k]}',`);
    };
    const genResxDistBody = (name, data) => {
        const content = JSON.parse(data);
        const strings = genResxStrs(content);
        return [
            autoGenStr,
            NEW_LINE,
            genNamespaceAssign(),
            NEW_LINE,
            genResxObj(strings.join(`${NEW_LINE}`), name),
        ].join('');
    };

    const genIStrs = json => {
        const keys = Object.keys(json).sort((a, b) => a > b);
        return keys.map(k => `${TAB}${k}: 'string';`);
    };
    const genIGlob = name => `declare interface ${tsGlobInterface} {${NEW_LINE}${TAB}${name}: ${name}${resxPrefix};${NEW_LINE}}`;
    const genIObj = (content, name) => `interface ${name}${resxPrefix} {${NEW_LINE}${content}${NEW_LINE}}`;

    const genTypesBody = (name, data) => {
        const content = JSON.parse(data);
        const strings = genIStrs(content);
        return [
            autoGenStr,
            tsLintDisable,
            NEW_LINE,
            genIObj(strings.join(`${NEW_LINE}`), name),
            NEW_LINE,
            NEW_LINE,
            genIGlob(name),
        ].join('');
    };

    const getChunksNames = fileNames => fileNames.map(fn => fn.split('.')[0])
        .filter((v, i, a) => a.indexOf(v) === i);

    const askForRecursiveActions = () => {
        inquirer
            .prompt({
                type: 'list',
                name: 'newKey',
                message: 'Would you like to do something else?',
                choices: yesNoList,
            })
            .then(a => {
                if (a.newKey === yesNo.yes) {
                    beginInteraction();
                }
            });
    };

    const regenerateDist = (interactive = true) => {
        genLogSection('regenerating dist files');
        const process = (chunkName, body, lang) => {
            const filePath = getDistFilePath(chunkName, lang);
            return writeFileAsync(filePath, body + NEW_LINE, writeOptions)
                .then(() => console.log(`${filePath} file is regenerated`))
                .catch(logErr);
        };

        readdirAsync(srcFolder)
            .then(readdirData => {
                if (!readdirData.length) {
                    return logErr('NOTHING TO REGENERATE');
                }
                const genDistOps = readdirData.map(srcFileName => {
                    const srcFilePath = `${srcFolder}${srcFileName}`;
                    return readFileAsync(srcFilePath, { encoding: 'utf8' })
                        .then(srcData => {
                            const filenameData = srcFileName.split('.');
                            const [chunkName, lang] = filenameData;
                            const resxBody = genResxDistBody(chunkName, srcData);
                            return process(chunkName, resxBody, lang);
                        })
                        .catch(logErr);
                });
                return Promise.all(genDistOps)
                    .then(() => {
                        const genTypesOps = getChunksNames(readdirData).map(chunkName => {
                            const defaultSrcPath = getDefSrcFilePath(chunkName);
                            let typeBody;
                            let typePath;
                            let id;

                            return readFileAsync(defaultSrcPath, { encoding: 'utf8' })
                                .then(defaultSrcData => {
                                    typePath = getDefTypesPath(chunkName);
                                    typeBody = genTypesBody(chunkName, defaultSrcData);
                                    return writeFileAsync(typePath, typeBody + NEW_LINE, writeOptions);
                                })
                                .then(() => {
                                    console.log(`${typePath} - file is regenerated`);
                                })
                                .catch(logErr);
                        });
                        
                        Promise.all(genTypesOps)
                            .then(() => {
                                if (interactive) {
                                    askForRecursiveActions();
                                }
                                else {
                                    console.log(colors.green('EVERYTHING IS OK. Enjoy ^_^'));
                                }
                            });
                    });
            })
            .catch(logErr);
    };

    const regenerateSrc = (interactive = true) => {
        genLogSection('regenerating src files');
        const processChunk = chunkName => {
            const defaultLangPath = getSrcFilePath(chunkName, defaultLang);
            return readFileAsync(defaultLangPath, { encoding: 'utf8' })
                .then(defaultLangData => {
                    const mainLangData = JSON.parse(defaultLangData);
                    const mainLangKeys = Object.keys(mainLangData);
                    const operations = languages.filter(lang => lang !== defaultLang)
                        .map(currentLang => {
                            const filePath = getSrcFilePath(chunkName, currentLang);
                            if (!fs.existsSync(filePath)) {
                                const body = mainLangKeys.reduce((acc, v) => {
                                    acc[v] = null;
                                    return acc;
                                }, {});
                                return writeFileAsync(filePath, JSON.stringify(body, null, 4), writeOptions)
                                    .then(() => console.log(colors.bgYellow(`${filePath} - file is updated`)))
                                    .catch(logErr);
                            }
                            return readFileAsync(filePath, { encoding: 'utf8' })
                                .then(currLangFiledata => {
                                    const langData = JSON.parse(currLangFiledata);
                                    const langDataKeys = Object.keys(langData);
                                    const absentKeys = mainLangKeys.filter(k => !(k in langData));
                                    const extraKeys = langDataKeys.filter(k => !(k in mainLangData));
                                    const hasExtraKeys = !!extraKeys.length;
                                    if (absentKeys.length || hasExtraKeys) {
                                        if (hasExtraKeys) {
                                            extraKeys.forEach(k => {
                                                delete langData[k];
                                            });
                                        }
                                        const absentData = absentKeys.reduce((acc, k) => {
                                            acc[k] = mainLangData[k];
                                            return acc;
                                        }, {});
                                        const newLangData = {
                                            ...langData,
                                            ...absentData,
                                        };
                                        return writeFileAsync(filePath, JSON.stringify(newLangData, null, 4), writeOptions)
                                            .then(() => {
                                                if (hasExtraKeys) {
                                                    console.log('----------------------');
                                                    console.log(`${filePath} - found extra keys`);
                                                    extraKeys.forEach(k => console.log(`'${k}' has been deleted`));
                                                    console.log(colors.bgYellow(`${filePath} - file is updated`));
                                                    console.log('----------------------');
                                                }
                                                else {
                                                    console.log(colors.bgYellow(`${filePath} - file is updated`));
                                                }
                                            })
                                            .catch(logErr);
                                    }
                                    return console.log(`${filePath} - file is up to date`);
                                })
                                .catch(logErr);
                        });
                    return Promise.all(operations).then(() => {});
                })
                .catch(logErr);
        };
        readdirAsync(srcFolder)
            .then(fileNames => {
                const chunkNames = getChunksNames(fileNames);
                const operations = chunkNames.map(chunkName => processChunk(chunkName));

                Promise.all(operations)
                    .then(() => {
                        regenerateDist(interactive);
                    });
            })
            .catch(logErr);
    };

    const generateEmptyChunk = (chunkName, callback) => {
        const operations = languages.map(l => {
            const filePath = getSrcFilePath(chunkName, l);
            return writeFileAsync(filePath, JSON.stringify({}), writeOptions)
                .then(() => console.log(`${filePath} empty resource file was created`))
                .catch(logErr);
        });

        Promise.all(operations)
            .then(() => {
                callback(chunkName);
            });
    };

    const beginInteraction = () => {
        const actions = {
            create: 'create',
            add: 'add',
            regenerateAll: 'regenerateAll',
        };

        const actonsList = [
            { name: 'Do everything GOOD', value: actions.regenerateAll },
            { name: 'Create new resx File', value: actions.create },
            { name: 'Add keys to existing one', value: actions.add },
        ];

        const startupQuestions = [
            {
                type: 'list', name: 'action', message: 'Select operation?', choices: actonsList,
            },
            {
                type: 'input',
                name: 'resxName',
                message: 'Give it a name: ',
                when: a => a.action === actions.create,
                validate: resxName => {
                    const exists = fs.existsSync(getSrcFilePath(resxName, defaultLang));
                    return exists ? 'Resource file already exists' : true;
                },
            },
        ];

        const createDefaultLangs = [defaultLang, 'ru'];
        const langList = languages.map(l => ({ name: l }));

        const doLangKeyValQuestions = (lang, keyName) => ({
            type: 'input',
            name: 'val',
            message: `'${lang}' value for '${keyName}'?`,
            validate: a => (a ? true : 'Can\'t add empty value'),
        });

        const doAddScenarioQuestions = resxName => [
            {
                type: 'input',
                name: 'keyName',
                message: 'Key name? ',
                validate: a => {
                    const fileContent = JSON.parse(fs.readFileSync(getSrcFilePath(resxName, defaultLang), 'utf8'));
                    return a in fileContent ? 'This key is already exists' : true;
                },
            },
            {
                type: 'checkbox',
                name: 'keyLangs',
                message: 'Select languages:',
                choices: langList,
                default: createDefaultLangs,
            },
        ];

        const doAdd = (resxName, keyName, keyLangs, langValPairs) => {
            const operations = keyLangs.map(l => {
                const filePath = getSrcFilePath(resxName, l);
                return readFileAsync(filePath, { encoding: 'utf8' })
                    .then(langData => {
                        const content = JSON.parse(langData);
                        const langVal = langValPairs[l];
                        const newLangData = {
                            ...content,
                            [keyName]: langVal,
                        };
                        return writeFileAsync(filePath, JSON.stringify(newLangData, null, 4), writeOptions);
                    })
                    .then(() => console.log(colors.bgYellow(`${filePath} file is updated`)))
                    .catch(logErr);
            });
            Promise.all(operations)
                .then(() => {
                    inquirer
                        .prompt({
                            type: 'list',
                            name: 'newKey',
                            message: 'add one more key?',
                            choices: yesNoList,
                        })
                        .then(a => {
                            if (a.newKey === yesNo.yes) {
                                addScenario(resxName);
                            }
                            else (regenerateSrc());
                        });
                });
        };

        const addScenario = resxName => {
            const askForValues = (keyName, keyLangs) => {
                const langValPairs = [];
                let iteration = 0;
                const askForValue = () => {
                    const currLang = keyLangs[iteration];
                    if (langValPairs.length < keyLangs.length) {
                        const question = doLangKeyValQuestions(currLang, keyName);
                        inquirer
                            .prompt(question)
                            .then(a => {
                                langValPairs.push({ [currLang]: a.val });
                                iteration += 1;
                                askForValue();
                            });
                    }
                    else {
                        const langData = langValPairs.reduce((acc, val) => {
                            const key = Object.keys(val)[0];
                            acc[key] = val[key];
                            return acc;
                        }, {});
                        doAdd(resxName, keyName, keyLangs, langData);
                    }
                };
                askForValue();
            };

            const askForKey = () => {
                inquirer
                    .prompt(doAddScenarioQuestions(resxName))
                    .then(a => {
                        askForValues(a.keyName, a.keyLangs);
                    });
            };
            
            askForKey();
        };

        const createScenario = resxName => {
            const callback = name => {
                inquirer
                    .prompt({
                        type: 'list',
                        name: 'addKey',
                        message: 'add keys??',
                        choices: yesNoList,
                    })
                    .then(a => {
                        if (a.addKey === yesNo.yes) {
                            addScenario(name);
                        }
                    });
            };
            generateEmptyChunk(resxName, callback);
        };

        const createSelectChankQuestion = chunkNames => {
            const chunkList = chunkNames.map(chunkName => ({ name: chunkName }));
            return {
                type: 'list',
                name: 'addKey',
                message: 'Select resource: ',
                choices: chunkList,
            };
        };

        const readChunksAndAsk = () => {
            readdirAsync(srcFolder)
                .then(srcDirData => {
                    if (!srcDirData.length) {
                        logErr(`NO RESOURCES FOUND IN ${srcFolder}`);
                        askForRecursiveActions();
                        return;
                    }
                    const question = createSelectChankQuestion(getChunksNames(srcDirData));
                    inquirer
                        .prompt(question)
                        .then(a => {
                            addScenario(a.addKey);
                        });
                })
                .catch(logErr);
        };

        inquirer
            .prompt(startupQuestions)
            .then(a => {
                if (a.action === actions.add) {
                    readChunksAndAsk();
                }
                if (a.action === actions.create) {
                    createScenario(a.resxName);
                }
                if (a.action === actions.regenerateAll) {
                    regenerateSrc(false);
                }
            });
    };

    // program
    //     .option('-d, --denisalexandrovichborovnev', 'Doing everything GOOD')
    //     .parse(process.argv);

    // if (program.denisalexandrovichborovnev) {
    //     regenerateSrc(false);
    // }
    // else {
    //     beginInteraction();
    // }
    regenerateSrc(false);
};

initModule({
    tabSize: 4,
    srcFolder: './resxSrc/',
    distFolder: './resxDist/',
    resxPrefix: 'Resx',
    jsNamespace: 'ep.resources',
    tsGlobInterface: 'EPResources',
    languages: ['en', 'ru', 'de', 'fr', 'es', 'it', 'pl', 'sk', 'tr'] 
});
module.exports = initModule;
//                          Functionality:
// TODO: + remove key functionality
// TODO: ???rework to classes
//                          Code refactoring:
// TODO: all openAsync(filePath, 'w', 666) move to helper function
// TODO: split all this hell into 3 modules
// TODO: move all trash (leke const variables, paths) to cfg and add ability to pass other config as it will be global package
// TODO: !!!move this package as global package

//                          Doubtful functionality:
// TODO: ???remove file functionality
