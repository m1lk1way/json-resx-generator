const fs = require('fs');
const { promisify } = require('util');
const inquirer = require('inquirer');
// const program = require('commander');
const colors = require('colors');

const readFileAsync = promisify(fs.readFile);
const openAsync = promisify(fs.open);
const writeAsync = promisify(fs.write);
const closeAsync = promisify(fs.close);
const readdirAsync = promisify(fs.readdir);

const NEW_LINE = '\r\n';
const TABSIZE = 4;
const TAB = new Array(TABSIZE + 1).join(' ');
const SRC_FOLDER = './resxSrc/';
const DIST_FOLDER = './resxDist/';
const RESX_PREFIX = 'Resx';
const NAMESPACE = 'ep.resources';
const GLOBAL_INTERFACE = 'EPResources';

const languages = [
    'en',
    'ru',
    'de',
    'fr',
    'es',
    'it',
    'pl',
    'sk',
    'tr',
];

const defaultLang = languages[0];

const yesNo = {
    yes: 'Yes',
    no: 'No',
};

const yesNoList = [
    { name: yesNo.yes },
    { name: yesNo.no },
];

const autoGenStr = `// This file is AUTOGENERATED, do not edit it manually!!!${NEW_LINE}`;
const tsLintDisable = `// tslint:disable${NEW_LINE}`;

const getSrcFilePath = (chunkName, lang) => `${SRC_FOLDER}${chunkName}.${lang}.json`;
const getDefSrcFilePath = chunkName => getSrcFilePath(chunkName, defaultLang);
const getDistFilePath = (chunkName, lang) => `${DIST_FOLDER}${chunkName}${RESX_PREFIX}.${lang}.js`;
const getDefTypesPath = chunkName => `${DIST_FOLDER}${chunkName}${RESX_PREFIX}.${defaultLang}.d.ts`;

const logErr = err => console.log(colors.red(`ERROR: ${err}`));

const genLogSection = sectionText => {
    console.log('-----------------------');
    console.log(`${sectionText}`);
    console.log('-----------------------');
};


const genNamespaceAssign = () => `${NAMESPACE} = ${NAMESPACE} || {};${NEW_LINE}`;
const genResxObj = (content, name) => `${NAMESPACE}.${name} = {${NEW_LINE}${content}${NEW_LINE}};`;
const genResxStrs = json => {
    const keys = Object.keys(json).sort((a, b) => a > b);
    return keys.map(k => `${TAB}${k}: '${json[k]}',`);
};
const genResxDistBody = (name, data) => {
    const content = JSON.parse(data);
    const strings = genResxStrs(content);
    return [
        autoGenStr,
        NEW_LINE,
        genNamespaceAssign(),
        NEW_LINE,
        genResxObj(strings.join(`${NEW_LINE}`), name),
    ].join('');
};

const genIStrs = json => {
    const keys = Object.keys(json).sort((a, b) => a > b);
    return keys.map(k => `${TAB}${k}: 'string';`);
};
const genIGlob = name => `declare interface ${GLOBAL_INTERFACE} {${NEW_LINE}${TAB}${name}: ${name}${RESX_PREFIX};${NEW_LINE}}`;
const genIObj = (content, name) => `interface ${name}${RESX_PREFIX} {${NEW_LINE}${content}${NEW_LINE}}`;

const genTypesBody = (name, data) => {
    const content = JSON.parse(data);
    const strings = genIStrs(content);
    return [
        autoGenStr,
        tsLintDisable,
        NEW_LINE,
        genIObj(strings.join(`${NEW_LINE}`), name),
        NEW_LINE,
        NEW_LINE,
        genIGlob(name),
    ].join('');
};

const getChunksNames = fileNames => fileNames.map(fn => fn.split('.')[0])
    .filter((v, i, a) => a.indexOf(v) === i);

const regenerateDist = (interactive = true) => {
    genLogSection('regenerating dist files');
    const process = (chunkName, body, lang) => {
        const filePath = getDistFilePath(chunkName, lang);
        return openAsync(filePath, 'w', 666)
            .then(id => (
                writeAsync(id, body + NEW_LINE, null, 'utf8')
                    .then(() => (
                        closeAsync(id)
                            .then(() => console.log(`${filePath} file is regenerated`))
                    ))
            ))
            .catch(logErr);
    };

    readdirAsync(SRC_FOLDER)
        .then(readdirData => {
            const genDistOps = readdirData.map(srcFileName => {
                const srcFilePath = `${SRC_FOLDER}${srcFileName}`;
                return readFileAsync(srcFilePath, { encoding: 'utf8' })
                    .then(srcData => {
                        const filenameData = srcFileName.split('.');
                        const [chunkName, lang] = filenameData;
                        const resxBody = genResxDistBody(chunkName, srcData);
                        return process(chunkName, resxBody, lang);
                    })
                    .catch(logErr);
            });
            Promise.all(genDistOps)
                .then(() => {
                    const genTypesOps = getChunksNames(readdirData).map(chunkName => {
                        const defaultSrcPath = getDefSrcFilePath(chunkName);
                        return readFileAsync(defaultSrcPath, { encoding: 'utf8' })
                            .then(defaultSrcData => {
                                const typePath = getDefTypesPath(chunkName);
                                const typeBody = genTypesBody(chunkName, defaultSrcData);
                                return openAsync(typePath, 'w', 666)
                                    .then(id => (
                                        writeAsync(id, typeBody + NEW_LINE, null, 'utf8')
                                            .then(() => (
                                                closeAsync(id)
                                                    .then(() => console.log(`${typePath} - d.ts file is updated`))
                                            ))
                                    ))
                                    .catch(logErr);
                            })
                            .catch(logErr);
                    });
                    
                    Promise.all(genTypesOps)
                        .then(() => {
                            if (interactive) {
                                inquirer
                                    .prompt({
                                        type: 'list',
                                        name: 'newKey',
                                        message: 'Would you like to do something else?',
                                        choices: yesNoList,
                                    })
                                    .then(a => {
                                        if (a.newKey === yesNo.yes) {
                                            beginInteraction();
                                        }
                                    });
                            }
                            else {
                                console.log(colors.green('EVERYTHING IS OK. Enjoy ^_^'));
                            }
                        });
                });
        })
        .catch(logErr);
};

const regenerateSrc = (interactive = true) => {
    genLogSection('regenerating src files');
    const processChunk = chunkName => {
        const defaultLangPath = getSrcFilePath(chunkName, defaultLang);
        return readFileAsync(defaultLangPath, { encoding: 'utf8' })
            .then(defaultLangData => {
                const mainLangData = JSON.parse(defaultLangData);
                const mainLangKeys = Object.keys(mainLangData);
                const operations = languages.filter(lang => lang !== defaultLang)
                    .map(currentLang => {
                        const filePath = getSrcFilePath(chunkName, currentLang);
                        if (!fs.existsSync(filePath)) {
                            return openAsync(filePath, 'w', 666)
                                .then(id => (
                                    writeAsync(id, defaultLangData + NEW_LINE, null, 'utf8')
                                        .then(() => (
                                            closeAsync(id)
                                                .then(() => console.log(colors.bgYellow(`${filePath} - file is updated`)))
                                        ))
                                ))
                                .catch(logErr);
                        }
                        return readFileAsync(filePath, { encoding: 'utf8' })
                            .then(currLangFiledata => {
                                const langData = JSON.parse(currLangFiledata);
                                const langDataKeys = Object.keys(langData);
                                const absentKeys = mainLangKeys.filter(k => !(k in langData));
                                const extraKeys = langDataKeys.filter(k => !(k in mainLangData));
                                const hasExtraKeys = !!extraKeys.length;
                                if (absentKeys.length || hasExtraKeys) {
                                    if (hasExtraKeys) {
                                        extraKeys.forEach(k => {
                                            delete langData[k];
                                        });
                                    }
                                    const absentData = absentKeys.reduce((acc, k) => {
                                        acc[k] = mainLangData[k];
                                        return acc;
                                    }, {});
                                    const newLangData = {
                                        ...langData,
                                        ...absentData,
                                    };
                                    return openAsync(filePath, 'w', 666)
                                        .then(id => (
                                            writeAsync(id, JSON.stringify(newLangData, null, 4), null, 'utf8')
                                                .then(() => (
                                                    closeAsync(id)
                                                        .then(() => {
                                                            if (hasExtraKeys) {
                                                                console.log('----------------------');
                                                                console.log(`${filePath} - found extra keys`);
                                                                extraKeys.forEach(k => console.log(`'${k}' has been deleted`));
                                                                console.log(colors.bgYellow(`${filePath} - file is updated`));
                                                                console.log('----------------------');
                                                            }
                                                            else {
                                                                console.log(colors.bgYellow(`${filePath} - file is updated`));
                                                            }
                                                        })
                                                ))
                                        ))
                                        .catch(logErr);
                                }
                                return console.log(`${filePath} - file is up to date`);
                            })
                            .catch(logErr);
                    });
                return Promise.all(operations).then(() => {});
            })
            .catch(logErr);
    };
    readdirAsync(SRC_FOLDER)
        .then(fileNames => {
            const chunkNames = getChunksNames(fileNames);
            const operations = chunkNames.map(chunkName => processChunk(chunkName));

            Promise.all(operations)
                .then(() => {
                    regenerateDist(interactive);
                });
        })
        .err(logErr);
};

const generateEmptyChunk = (chunkName, callback) => {
    const operations = languages.map(l => {
        const filePath = getSrcFilePath(chunkName, l);
        return openAsync(filePath, 'w', 666)
            .then(id => (
                writeAsync(id, JSON.stringify({}), null, 'utf8')
                    .then(() => (
                        closeAsync(id)
                            .then(() => console.log(`${filePath} empty resource file was created`))
                    ))
            ))
            .catch(logErr);
    });

    Promise.all(operations)
        .then(() => {
            callback(chunkName);
        });
};

const beginInteraction = () => {
    const actions = {
        create: 'create',
        add: 'add',
        regenerateAll: 'regenerateAll',
    };

    const actonsList = [
        { name: 'Do everything GOOD', value: actions.regenerateAll },
        { name: 'Create new resx File', value: actions.create },
        { name: 'Add keys to existing one', value: actions.add },
    ];

    const startupQuestions = [
        {
            type: 'list', name: 'action', message: 'What would you like to do', choices: actonsList,
        },
        {
            type: 'input',
            name: 'resxName',
            message: 'What\'s the name of resx file? ',
            when: a => a.action === actions.add,
            validate: resxName => {
                const exists = fs.existsSync(getSrcFilePath(resxName, defaultLang));
                return exists ? true : 'Resource doesn\'t exists';
            },
        },
        {
            type: 'input',
            name: 'resxName',
            message: 'Give it a name: ',
            when: a => a.action === actions.create,
            validate: resxName => {
                const exists = fs.existsSync(getSrcFilePath(resxName, defaultLang));
                return exists ? 'Resource file already exists' : true;
            },
        },
    ];

    const createDefaultLangs = [defaultLang, 'ru'];
    const langList = languages.map(l => ({ name: l }));

    const doLangKeyValQuestions = lang => ({
        type: 'input',
        name: 'val',
        message: `${lang} value for this key?`,
        validate: a => (a ? true : 'Can\'t add empty value'),
    });

    const doAddScenarioQuestions = resxName => [
        {
            type: 'input',
            name: 'keyName',
            message: 'Key name? ',
            validate: a => {
                const fileContent = JSON.parse(fs.readFileSync(getSrcFilePath(resxName, defaultLang), 'utf8'));
                return a in fileContent ? 'This key is already exists' : true;
            },
        },
        {
            type: 'checkbox',
            name: 'keyLangs',
            message: 'Which lang resources would you like to add keys to? ',
            choices: langList,
            default: createDefaultLangs,
        },
    ];

    const doAdd = (resxName, keyName, keyLangs, langValPairs) => {
        const operations = keyLangs.map(l => {
            const filePath = getSrcFilePath(resxName, l);
            return readFileAsync(filePath, { encoding: 'utf8' })
                .then(langData => {
                    const content = JSON.parse(langData);
                    const langVal = langValPairs[l];
                    const newLangData = {
                        ...content,
                        [keyName]: langVal,
                    };
                    return openAsync(filePath, 'w', 666)
                        .then(id => (
                            writeAsync(id, JSON.stringify(newLangData, null, 4), null, 'utf8')
                                .then(() => (
                                    closeAsync(id)
                                        .then(() => console.log(colors.bgYellow(`${filePath} file is updated`)))
                                ))
                        ))
                        .catch(logErr);
                })
                .catch(logErr);
        });
        Promise.all(operations)
            .then(() => {
                inquirer
                    .prompt({
                        type: 'list',
                        name: 'newKey',
                        message: 'Would you like to add one more key?',
                        choices: yesNoList,
                    })
                    .then(a => {
                        if (a.newKey === yesNo.yes) {
                            addScenario(resxName);
                        }
                        else (regenerateSrc());
                    });
            });
    };

    const addScenario = resxName => {
        const askForValues = (keyName, keyLangs) => {
            const langValPairs = [];
            let iteration = 0;
            const askForValue = () => {
                const currLang = keyLangs[iteration];
                if (langValPairs.length < keyLangs.length) {
                    const question = doLangKeyValQuestions(currLang);
                    inquirer
                        .prompt(question)
                        .then(a => {
                            langValPairs.push({ [currLang]: a.val });
                            iteration += 1;
                            askForValue();
                        });
                }
                else {
                    const langData = langValPairs.reduce((acc, val) => {
                        const key = Object.keys(val)[0];
                        acc[key] = val[key];
                        return acc;
                    }, {});
                    doAdd(resxName, keyName, keyLangs, langData);
                }
            };
            askForValue();
        };

        const askForKey = () => {
            inquirer
                .prompt(doAddScenarioQuestions(resxName))
                .then(a => {
                    askForValues(a.keyName, a.keyLangs);
                });
        };
        
        askForKey();
    };

    const createScenario = resxName => {
        const callback = name => {
            inquirer
                .prompt({
                    type: 'list',
                    name: 'addKey',
                    message: 'Would you like to add some keys to it??',
                    choices: yesNoList,
                })
                .then(a => {
                    if (a.addKey === yesNo.yes) {
                        addScenario(name);
                    }
                });
        };
        generateEmptyChunk(resxName, callback);
    };

    inquirer
        .prompt(startupQuestions)
        .then(a => {
            if (a.action === actions.add) {
                addScenario(a.resxName);
            }
            if (a.action === actions.create) {
                createScenario(a.resxName);
            }
            if (a.action === actions.regenerateAll) {
                regenerateSrc(false);
            }
        });
};

beginInteraction();
// regenerateSrc(false);
// regenerateDist(false);

//                          Functionality:
// TODO: + remove key functionality
// TODO: ???rework to classes
//                          Code refactoring:
// TODO: all openAsync(filePath, 'w', 666) move to helper function
// TODO: split all this hell into 3 modules
// TODO: move all trash (leke const variables, paths) to cfg and add ability to pass other config
// TODO: !!!move this package as global package

//                          Doubtful functionality:
// TODO: ???remove file functionality
